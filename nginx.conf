worker_processes auto;
rtmp_auto_push on;

# Logging configuration
error_log /dev/stdout info;

events {
    worker_connections 4096;
}

http {
    include       /usr/local/nginx/conf/mime.types;
    default_type  application/octet-stream;
    
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;

    server {
        listen 8080;

        # HTTP-FLV live streaming endpoint (low latency playback)
        # URL format: http://server:8080/live?app=live&stream=streamname
        location /live {
            flv_live on;
            chunked_transfer_encoding on;
            
            # CORS headers for web players
            add_header 'Access-Control-Allow-Origin' '*';
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS';
            add_header 'Access-Control-Allow-Headers' 'Range';
        }
        
        # Serve HLS fragments
        location /hls {
            types {
                application/vnd.apple.mpegurl m3u8;
                video/mp2t ts;
            }
            root /tmp;
            add_header Cache-Control no-cache;
            
            # CORS headers for web players
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods 'GET, OPTIONS';
            add_header Access-Control-Allow-Headers 'Range';
        }
        
        # RTMP statistics in JSON format
        location /stat {
            rtmp_stat all;
            rtmp_stat_format json;
        }
        
        # Control interface (optional, for future use)
        location /control {
            rtmp_control all;
        }
        
        # RTMP callback handlers
        location /on_publish {
            access_log /dev/stdout;
            return 200;
        }
        
        location /on_play {
            access_log /dev/stdout;
            return 200;
        }
        
        location /on_publish_done {
            access_log /dev/stdout;
            return 200;
        }
        
        location /on_play_done {
            access_log /dev/stdout;
            return 200;
        }
    }
}

rtmp {
    out_queue 4096;
    out_cork 8;
    max_streams 128;
    timeout 15s;
    drop_idle_publisher 15s;
    
    log_interval 5s;
    log_size 1m;

    server {
        listen 1935;
        listen [::]:1935 ipv6only=on;
        chunk_size 4096;
        
        # Enable access logging for RTMP connections
        access_log /dev/stdout;

        application live {
            live on;

            # GOP cache - reduces initial stream latency by 2-4 seconds
            # Caches the last GOP (Group of Pictures) so new viewers get instant playback
            gop_cache on;
            gop_cache_count 1;  # Cache 1 GOP (~2-4 sec). Use 2 for smoother start but higher latency

            # Try to align segments to keyframes / timestamps
            hls on;
            hls_path /tmp/hls;

            hls_fragment 2;                     # shorter segments = quicker recovery
            hls_playlist_length 12;             # keep it tighter for live (was 60)
            hls_cleanup on;

            hls_continuous off;                 # important if your upstream restarts/resets time
            hls_fragment_slicing aligned;       # keyframe-aligned slicing (if available)
            hls_fragment_naming sequential;     # avoid timestamp-based names (if available)
            hls_sync 100ms;                     # tighten fragment start timing (if available)

            record off;
            allow publish all;
            allow play all;
        }

        application publish {
            live on;
            
            # GOP cache for this application too
            gop_cache on;
            gop_cache_count 1;
            
            record off;
            allow publish all;
            allow play all;
        }
    }
}